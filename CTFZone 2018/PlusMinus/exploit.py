#!/usr/bin/env python2

from pwn import *
import re, sys

OPS = {
    '+': True,
    '-': True,
    '*': True,
    '/': True,
    '(': True,
    ')': True,
    # 'POP'
}

def last_op(sol):
    for i in range(len(sol)-1, -1, -1):
        if sol[i] in OPS: return sol[i]
    return None

def solve(movements, opened_count, nums, solution, should):
    if len(nums) == 0:
        solution += ')'*opened_count
        try:
            if abs(should - eval(solution)) < 1e-8:
                print("found solution: {}".format(solution))
                return solution
            return None
        except ZeroDivisionError:
            return None
        except:
            print("Got an error in: {}".format(solution))
            return None
    best = (False,)
    if opened_count != 0 and last_op(solution) != '(' and (solution[-1] not in OPS or solution[-1] == ')'):
        next_ops = ['+', '-', '*', '/']
        solution += ')'
        answer = solve(next_ops, opened_count-1, nums, solution, should)
        solution = solution[:-1]
        if answer is not None:
            return answer
    for op in movements:
        answer = None
        if op == 'POP':
            next_ops = ['+', '-', '*', '/']
            num = nums.pop()
            solution += num
            answer = solve(next_ops, opened_count, nums, solution, should)
            solution = solution[:-len(num)]
            nums.append(num)
        elif op == '(':
            if opened_count > 1: continue
            next_ops = ['+', '-', '*', '/']
            num = nums.pop()
            solution += op
            solution += num
            answer = solve(next_ops, opened_count+1, nums, solution, should)
            solution = solution[:-len(num)-len(op)]
            nums.append(num)
        else:
            next_ops = ['POP', '(']
            solution += op
            answer = solve(next_ops, opened_count, nums, solution, should)
            solution = solution[:-len(op)]
        if answer is not None:
            return answer
    return None

def abc_s(s):
    if s[0] == '-':
        return s[1:]
    return s
def float_s(s):
    if '.' not in s:
        return s + '.0'
    return s

r = remote('ppc-01.v7frkwrfyhsjtbpfcppnu.ctfz.one', 2445)
while True:
    s = r.recvline().strip()
    print('solving {}'.format(s))

    nums = s.split(' ')
    should = float(nums.pop())
    org_nums = nums
    nums = list(map(lambda x: float_s(abc_s(x)), nums))
    nums.reverse()
    solution = solve(['POP', '-', '('], 0, nums, "", should)

    if solution is None:
        sys.exit("there's no solution")

    solution = re.split(r'([0-9.]+)', solution)
    org_nums.reverse()
    def replace_with_original(x):
        if len(x) > 0 and (x[0] == '.' or '0' <= x[0] <= '9'):
            return org_nums.pop()
        else:
            return x
    solution = map(replace_with_original, solution)
    solution = ''.join(solution)
    print('solvution {}'.format(solution))
    r.send(solution+"\n")
    answer = r.recvline().strip()
    if answer != "Success":
        sys.exit(answer)
